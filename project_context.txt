# PROJECT CONTEXT DOCUMENT
# Generated on: Sun May 11 02:36:37 PM IST 2025
# Purpose: This document contains the structure and content of the project for LLM context

## TABLE OF CONTENTS
1. Project Structure
2. File Contents


## 1. PROJECT STRUCTURE

Note: 'tree' command not found, using 'find' command instead.
```
DIRECTORIES:
.
./auth
./auth/__pycache__
./data
./data/historical
./data/logs
./data/__pycache__
./data/results
./execution
./execution/__pycache__
./notebooks
./risk
./strategy
./tests
./tests/__pycache__
./trading_env
./utils

FILES:
./authenticate.py
./auth/__init__.py
./auth/zerodha_auth.py
./config.py
./corrected_auth_test.py
./corrected_websocket_test.py
./data/historical_data.py
./data/__init__.py
./data/realtime_data.py
./.env
./execution/__init__.py
./execution/order_manager.py
./fetch_historical_data.py
./__init__.py
./README.md
./risk/__init__.py
./risk/risk_manager.py
./run_backtest.py
./run_live_trading.py
./run_optimization.py
./run_paper_trading.py
./setup.py
./strategy/base_strategy.py
./strategy/__init__.py
./strategy/moving_average.py
./strategy/rsi_strategy.py
./system.py
./test_setup.py
./tests/__init__.py
./tests/test_auth.py
./tests/test_data.py
./tests/test_execution.py
./tests/test_realtime_data.py
./tests/test_risk.py
./tests/test_strategy.py
./tests/test_system.py
./test_websocket.py
./utils/helpers.py
./utils/__init__.py
./utils/logger.py
```

## 2. FILE CONTENTS


### ./authenticate.py

Type: Python Source Code
Size: 0
```py
```

### ./auth/__init__.py

Type: Python Source Code
Size: 4.0K
```py
"""auth module for the trading system."""
```

### ./auth/zerodha_auth.py

Type: Python Source Code
Size: 4.0K
```py
"""
Authentication module for Zerodha API.
"""
import os
import logging
from typing import Dict, Optional, Union
from kiteconnect import KiteConnect

logger = logging.getLogger(__name__)

class ZerodhaAuth:
    """Handles authentication with Zerodha's Kite Connect API."""
    
    def __init__(self, api_key: str, api_secret: str, access_token: Optional[str] = None) -> None:
        """
        Initialize the authentication module.
        
        Args:
            api_key: Zerodha API key
            api_secret: Zerodha API secret
            access_token: Optional access token (if already authenticated)
        """
        self.api_key = api_key
        self.api_secret = api_secret
        self.kite = KiteConnect(api_key=api_key)
        
        if access_token:
            self.set_access_token(access_token)
    
    def get_login_url(self) -> str:
        """Generate the login URL for Zerodha authentication."""
        return self.kite.login_url()
    
    def generate_session(self, request_token: str) -> str:
        """
        Generate a session using the request token.
        
        Args:
            request_token: Request token obtained after login
            
        Returns:
            Access token for API requests
        """
        data = self.kite.generate_session(request_token, api_secret=self.api_secret)
        access_token = data["access_token"]
        self.set_access_token(access_token)
        logger.info("Successfully authenticated with Zerodha")
        return access_token
    
    def set_access_token(self, access_token: str) -> None:
        """
        Set the access token for API requests.
        
        Args:
            access_token: Access token to use for API requests
        """
        self.access_token = access_token
        self.kite.set_access_token(access_token)
    
    def validate_connection(self) -> bool:
        """
        Validate that the connection is working by fetching user profile.
        
        Returns:
            True if connection is valid, False otherwise
        """
        try:
            profile = self.kite.profile()
            logger.info(f"Connected to Zerodha as: {profile['user_name']}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to Zerodha: {e}")
            return False
    
    def get_kite(self) -> KiteConnect:
        """
        Get the KiteConnect instance.
        
        Returns:
            Configured KiteConnect instance
        """
        return self.kite```

### ./config.py

Type: Python Source Code
Size: 0
```py
```

### ./corrected_auth_test.py

Type: Python Source Code
Size: 8.0K
```py
#!/usr/bin/env python
"""
Zerodha Authentication Test Script (Using ZerodhaAuth Class)

This script tests the authentication process with Zerodha API using our custom ZerodhaAuth class.
"""
import os
import sys
import logging
from dotenv import load_dotenv, set_key

# Import our ZerodhaAuth class
# Note: Adjust the import path based on your actual project structure
from auth.zerodha_auth import ZerodhaAuth

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def save_to_env(api_key, api_secret, access_token):
    """Save credentials to .env file."""
    try:
        # Create .env file if it doesn't exist
        if not os.path.exists('.env'):
            with open('.env', 'w') as f:
                pass
                
        # Update environment variables
        set_key('.env', 'KITE_API_KEY', api_key)
        set_key('.env', 'KITE_API_SECRET', api_secret)
        set_key('.env', 'KITE_ACCESS_TOKEN', access_token)
        
        logger.info("Credentials saved to .env file")
        return True
    except Exception as e:
        logger.error(f"Failed to save credentials: {e}")
        return False

def test_authentication():
    """Test the Zerodha authentication process using ZerodhaAuth class."""
    print("\n" + "="*80)
    print("ZERODHA AUTHENTICATION TEST USING ZerodhaAuth CLASS")
    print("="*80)
    
    # Step 1: Load environment variables
    load_dotenv()
    
    # Check if API key and secret are available
    api_key = os.getenv("KITE_API_KEY")
    api_secret = os.getenv("KITE_API_SECRET")
    
    if not api_key:
        api_key = input("\nEnter your Zerodha API key: ")
    
    if not api_secret:
        api_secret = input("Enter your Zerodha API secret: ")
    
    if not api_key or not api_secret:
        logger.error("API key and secret are required")
        return False
    
    # Step 2: Initialize ZerodhaAuth
    try:
        auth = ZerodhaAuth(api_key, api_secret)
        logger.info("ZerodhaAuth initialized")
    except Exception as e:
        logger.error(f"Failed to initialize ZerodhaAuth: {e}")
        return False
    
    # Step 3: Generate login URL
    login_url = auth.get_login_url()
    print("\nSTEP 1: Open this URL in your browser to log in:")
    print(login_url)
    print("\nAfter logging in, you will be redirected to your redirect URL.")
    print("The redirect URL will contain a 'request_token' parameter.")
    print("Example: https://your-redirect-url.com/callback?request_token=xxxxx&action=login&status=success")
    
    # Step 4: Get request token from user
    request_token = input("\nSTEP 2: Enter the request token from the redirect URL: ")
    if not request_token:
        logger.error("Request token is required")
        return False
    
    # Step 5: Generate session and get access token
    try:
        print("\nSTEP 3: Generating access token...")
        access_token = auth.generate_session(request_token)
        logger.info("Access token generated successfully")
    except Exception as e:
        logger.error(f"Failed to generate access token: {e}")
        logger.error("Please make sure the request token is correct and not expired")
        return False
    
    # Step 6: Verify connection
    try:
        print("\nSTEP 4: Verifying connection...")
        if auth.validate_connection():
            print("\nConnection verified!")
            # Get the kite connect instance to fetch profile
            kite = auth.get_kite()
            profile = kite.profile()
            print(f"Logged in as: {profile['user_name']}")
            print(f"User ID: {profile['user_id']}")
            print(f"Email: {profile['email']}")
        else:
            logger.error("Connection validation failed")
            return False
    except Exception as e:
        logger.error(f"Failed to verify connection: {e}")
        return False
    
    # Step 7: Save credentials to .env file
    print("\nSTEP 5: Saving credentials to .env file...")
    if not save_to_env(api_key, api_secret, access_token):
        logger.warning("Failed to save credentials to .env file. You may need to update them manually.")
    
    # Final summary
    print("\n" + "="*80)
    print("AUTHENTICATION TEST COMPLETED SUCCESSFULLY!")
    print("="*80)
    print("\nYour API key, secret, and access token are working correctly.")
    print("ZerodhaAuth class is functioning properly.")
    print("\nIMPORTANT: The access token is valid until the end of the trading day.")
    print("You will need to generate a new access token tomorrow.")
    
    return True

if __name__ == "__main__":
    if not test_authentication():
        sys.exit(1)```

### ./corrected_websocket_test.py

Type: Python Source Code
Size: 8.0K
```py
#!/usr/bin/env python
"""
Zerodha WebSocket Connection Test Script (Using Trading System Classes)

This script tests the WebSocket connection with Zerodha's streaming API
using our custom RealTimeDataManager class.
"""
import os
import sys
import time
import logging
from dotenv import load_dotenv

# Import our trading system classes
# Note: Adjust the import paths based on your actual project structure
from auth.zerodha_auth import ZerodhaAuth
from data.realtime_data import RealTimeDataManager
from data.historical_data import HistoricalDataManager

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def test_websocket():
    """Test the WebSocket connection using our trading system classes."""
    print("\n" + "="*80)
    print("ZERODHA WEBSOCKET TEST USING TRADING SYSTEM CLASSES")
    print("="*80)
    
    # Load environment variables
    load_dotenv()
    
    # Check if API key and access token are available
    api_key = os.getenv("KITE_API_KEY")
    api_secret = os.getenv("KITE_API_SECRET")
    access_token = os.getenv("KITE_ACCESS_TOKEN")
    
    if not api_key or not api_secret or not access_token:
        logger.error("API key, secret, and access token are required")
        logger.error("Run the authentication test script first to generate them")
        return False
    
    # Initialize ZerodhaAuth
    try:
        auth = ZerodhaAuth(api_key, api_secret, access_token)
        if not auth.validate_connection():
            logger.error("Connection validation failed. Your access token may be expired.")
            logger.error("Run the authentication test script again to get a new access token.")
            return False
        logger.info("ZerodhaAuth initialized and connection validated")
    except Exception as e:
        logger.error(f"Failed to initialize ZerodhaAuth: {e}")
        return False
    
    # Get KiteConnect instance
    kite = auth.get_kite()
    
    # Initialize HistoricalDataManager to get instrument tokens
    try:
        print("\nFetching instrument tokens...")
        historical_data_manager = HistoricalDataManager(kite)
        
        # Define symbols to track
        symbols = ["RELIANCE", "TCS", "INFY", "HDFCBANK", "ICICIBANK"]
        
        # Get instrument tokens
        token_map = historical_data_manager.get_instrument_tokens(symbols)
        symbol_token_map = {v: k for k, v in token_map.items()}
        
        tokens = list(token_map.values())
        
        if not tokens:
            logger.error("No instrument tokens found for the specified symbols")
            return False
            
        # Print tokens
        for symbol, token in token_map.items():
            print(f"  {symbol}: {token}")
            
    except Exception as e:
        logger.error(f"Failed to fetch instruments: {e}")
        return False
    
    # Dictionary to store received ticks
    received_ticks = {}
    
    # Custom callback for ticks
    def custom_tick_callback(symbol, tick):
        """Custom callback for tick data."""
        received_ticks[symbol] = tick
        print(f"Tick: {symbol} - LTP: ₹{tick['last_price']:.2f}, Volume: {tick.get('volume_traded', 'N/A')}")
    
    # Initialize RealTimeDataManager
    try:
        print("\nInitializing WebSocket connection...")
        realtime_data = RealTimeDataManager(api_key, access_token)
        
        # Register custom callbacks
        realtime_data.register_callback('on_tick', custom_tick_callback)
        
        # Subscribe to tokens
        realtime_data.subscribe(tokens, symbol_token_map, token_map)
        
        # Start the WebSocket connection
        realtime_data.start()
        
        print("\nWebSocket connected! Receiving market data for 60 seconds...")
        print("Press Ctrl+C to stop earlier")
        
        # Wait for 60 seconds to receive ticks
        try:
            start_time = time.time()
            while time.time() - start_time < 60:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\nTest stopped by user")
        
        # Stop the WebSocket connection
        realtime_data.stop()
        
        # Print summary
        print("\n" + "="*80)
        print("WEBSOCKET TEST SUMMARY")
        print("="*80)
        print(f"Received market data for {len(received_ticks)} symbols:")
        
        for symbol, tick in received_ticks.items():
            print(f"  {symbol}: ₹{tick['last_price']:.2f}")
        
        print("\nRealTimeDataManager is working correctly!")
        
        return True
        
    except Exception as e:
        logger.error(f"WebSocket test failed: {e}")
        return False

if __name__ == "__main__":
    if not test_websocket():
        sys.exit(1)```

### ./data/historical_data.py

Type: Python Source Code
Size: 8.0K
```py
"""
Historical Data Management Module

This module handles fetching, storing, and managing historical market data
from Zerodha for backtesting and strategy development.
"""
import os
import logging
from datetime import datetime, timedelta
import pandas as pd
from kiteconnect import KiteConnect

logger = logging.getLogger(__name__)

class HistoricalDataManager:
    """Manages historical market data for backtesting and analysis."""
    
    def __init__(self, kite, data_dir="data/historical"):
        """
        Initialize the historical data manager.
        
        Args:
            kite: KiteConnect instance for API requests
            data_dir: Directory to store historical data
        """
        self.kite = kite
        self.data_dir = data_dir
        self.instrument_tokens = {}
        
        # Create data directory if it doesn't exist
        os.makedirs(data_dir, exist_ok=True)
    
    def get_instrument_tokens(self, symbols, exchange="NSE"):
        """
        Get instrument tokens for the given symbols.
        
        Args:
            symbols: List of trading symbols
            exchange: Exchange name (default: NSE)
            
        Returns:
            Dictionary mapping symbols to their instrument tokens
        """
        all_instruments = self.kite.instruments(exchange)
        instrument_tokens = {}
        
        for instrument in all_instruments:
            if instrument['tradingsymbol'] in symbols:
                instrument_tokens[instrument['tradingsymbol']] = instrument['instrument_token']
                
        self.instrument_tokens.update(instrument_tokens)
        return instrument_tokens
    
    def fetch_historical_data(self, instrument_token, from_date, to_date, interval="day"):
        """
        Fetch historical data for a given instrument.
        
        Args:
            instrument_token: Instrument token
            from_date: Start date (format: YYYY-MM-DD)
            to_date: End date (format: YYYY-MM-DD)
            interval: Candle interval (day, minute, etc.)
            
        Returns:
            DataFrame with historical data
        """
        try:
            data = self.kite.historical_data(
                instrument_token=instrument_token,
                from_date=from_date,
                to_date=to_date,
                interval=interval
            )
            df = pd.DataFrame(data)
            
            # Set date as index if exists
            if 'date' in df.columns:
                df.set_index('date', inplace=True)
                
            return df
            
        except Exception as e:
            logger.error(f"Error fetching historical data: {e}")
            return pd.DataFrame()
    
    def fetch_multiple_symbols(self, symbols, from_date, to_date, interval="day", exchange="NSE"):
        """
        Fetch historical data for multiple symbols.
        
        Args:
            symbols: List of trading symbols
            from_date: Start date (format: YYYY-MM-DD)
            to_date: End date (format: YYYY-MM-DD)
            interval: Candle interval (day, minute, etc.)
            exchange: Exchange name (default: NSE)
            
        Returns:
            Dictionary mapping symbols to their historical data
        """
        instrument_tokens = self.get_instrument_tokens(symbols, exchange)
        
        data = {}
        for symbol, token in instrument_tokens.items():
            logger.info(f"Fetching data for {symbol} (token: {token})")
            df = self.fetch_historical_data(token, from_date, to_date, interval)
            if not df.empty:
                # Save data to disk
                self.save_data(symbol, df)
                data[symbol] = df
        
        return data
    
    def save_data(self, symbol, data):
        """
        Save historical data to disk.
        
        Args:
            symbol: Trading symbol
            data: DataFrame with historical data
        """
        filename = os.path.join(self.data_dir, f"{symbol}.csv")
        data.to_csv(filename)
        logger.info(f"Saved data for {symbol} to {filename}")
    
    def load_data(self, symbol):
        """
        Load historical data from disk.
        
        Args:
            symbol: Trading symbol
            
        Returns:
            DataFrame with historical data, or None if not found
        """
        filename = os.path.join(self.data_dir, f"{symbol}.csv")
        try:
            df = pd.read_csv(filename, index_col=0, parse_dates=True)
            logger.info(f"Loaded data for {symbol} from {filename}")
            return df
        except FileNotFoundError:
            logger.warning(f"No data file found for {symbol}")
            return None
        except Exception as e:
            logger.error(f"Error loading data for {symbol}: {e}")
            return None
    
    def load_multiple_symbols(self, symbols):
        """
        Load historical data for multiple symbols from disk.
        
        Args:
            symbols: List of trading symbols
            
        Returns:
            Dictionary mapping symbols to their historical data
        """
        data = {}
        for symbol in symbols:
            df = self.load_data(symbol)
            if df is not None:
                data[symbol] = df
        
        return data
    
    def get_latest_data(self, symbol, days=30):
        """
        Get the latest N days of data for a symbol.
        
        Args:
            symbol: Trading symbol
            days: Number of days of data to return
            
        Returns:
            DataFrame with the latest N days of data
        """
        df = self.load_data(symbol)
        if df is not None and len(df) > days:
            return df.iloc[-days:]
        return df```

### ./data/__init__.py

Type: Python Source Code
Size: 4.0K
```py

"""
Data module for trading system.

This module provides data handling functionality for the trading system,
including historical data management and real-time data streaming.
"""

from .historical_data import HistoricalDataManager
from .realtime_data import RealTimeDataManager```

### ./data/realtime_data.py

Type: Python Source Code
Size: 12K
```py
"""
Real-Time Data Manager Module

This module handles real-time market data from Zerodha using WebSockets.
It provides functionality to subscribe to market ticks and process them
in real-time for trading decisions.
"""
import logging
from typing import Dict, List, Any, Optional, Callable
from kiteconnect import KiteTicker

logger = logging.getLogger(__name__)

class RealTimeDataManager:
    """
    Manages real-time market data using WebSockets.
    
    This class handles the WebSocket connection to Zerodha's servers,
    subscribes to market ticks for specified instruments, and provides
    callbacks for processing the real-time data.
    """
    
    def __init__(self, api_key: str, access_token: str):
        """
        Initialize the real-time data manager.
        
        Args:
            api_key: Zerodha API key
            access_token: Zerodha access token
        """
        self.api_key = api_key
        self.access_token = access_token
        self.ticker = None
        self.is_connected = False
        self.subscribed_tokens = []
        self.token_symbol_map = {}  # Maps token to symbol
        self.symbol_token_map = {}  # Maps symbol to token
        self.latest_ticks = {}      # Stores latest tick for each symbol
        
        # Callbacks dictionary
        self.callbacks = {
            'on_tick': None,
            'on_connect': None,
            'on_close': None,
            'on_error': None,
            'on_reconnect': None,
            'on_noreconnect': None,
            'on_order_update': None
        }
    
    def start(self):
        """
        Start the WebSocket connection.
        
        Returns:
            True if connection started successfully, False otherwise
        """
        try:
            # Initialize KiteTicker
            self.ticker = KiteTicker(self.api_key, self.access_token)
            
            # Set up callbacks
            self.ticker.on_ticks = self._on_ticks
            self.ticker.on_connect = self._on_connect
            self.ticker.on_close = self._on_close
            self.ticker.on_error = self._on_error
            self.ticker.on_reconnect = self._on_reconnect
            self.ticker.on_noreconnect = self._on_noreconnect
            self.ticker.on_order_update = self._on_order_update
            
            # Connect to WebSocket server
            self.ticker.connect(threaded=True)
            logger.info("WebSocket connection started")
            return True
        
        except Exception as e:
            logger.error(f"Failed to start WebSocket connection: {e}")
            return False
    
    def stop(self):
        """
        Stop the WebSocket connection.
        
        Returns:
            True if stopped successfully, False otherwise
        """
        try:
            if self.ticker:
                self.ticker.close()
                self.ticker = None
                self.is_connected = False
                logger.info("WebSocket connection stopped")
            return True
        
        except Exception as e:
            logger.error(f"Failed to stop WebSocket connection: {e}")
            return False
    
    def subscribe(self, tokens: List[int], token_symbol_map: Optional[Dict[int, str]] = None, 
                symbol_token_map: Optional[Dict[str, int]] = None):
        """
        Subscribe to the given list of instrument tokens.
        
        Args:
            tokens: List of instrument tokens to subscribe to
            token_symbol_map: Optional dictionary mapping tokens to symbols
            symbol_token_map: Optional dictionary mapping symbols to tokens
            
        Returns:
            True if subscription successful, False otherwise
        """
        try:
            # Store tokens
            self.subscribed_tokens = tokens
            
            # Update token-symbol mappings if provided
            if token_symbol_map:
                self.token_symbol_map.update(token_symbol_map)
            
            if symbol_token_map:
                self.symbol_token_map.update(symbol_token_map)
            
            # Subscribe to tokens if connected
            if self.ticker and self.is_connected:
                self.ticker.subscribe(tokens)
                self.ticker.set_mode(self.ticker.MODE_FULL, tokens)
                logger.info(f"Subscribed to {len(tokens)} instrument tokens")
            else:
                logger.warning("WebSocket not connected. Tokens will be subscribed on connection.")
            
            return True
        
        except Exception as e:
            logger.error(f"Failed to subscribe to tokens: {e}")
            return False
    
    def unsubscribe(self, tokens: List[int]):
        """
        Unsubscribe from the given list of instrument tokens.
        
        Args:
            tokens: List of instrument tokens to unsubscribe from
            
        Returns:
            True if unsubscription successful, False otherwise
        """
        try:
            if self.ticker and self.is_connected:
                self.ticker.unsubscribe(tokens)
                logger.info(f"Unsubscribed from {len(tokens)} instrument tokens")
                
                # Remove from subscribed tokens
                self.subscribed_tokens = [t for t in self.subscribed_tokens if t not in tokens]
                
                # Remove from latest ticks
                for token in tokens:
                    symbol = self.token_symbol_map.get(token)
                    if symbol and symbol in self.latest_ticks:
                        del self.latest_ticks[symbol]
            else:
                logger.warning("WebSocket not connected. Cannot unsubscribe.")
            
            return True
        
        except Exception as e:
            logger.error(f"Failed to unsubscribe from tokens: {e}")
            return False
    
    def set_mode(self, mode: str, tokens: List[int]):
        """
        Set mode for the given list of instrument tokens.
        
        Args:
            mode: Mode to set (MODE_LTP, MODE_QUOTE, MODE_FULL)
            tokens: List of instrument tokens
            
        Returns:
            True if mode set successfully, False otherwise
        """
        try:
            if self.ticker and self.is_connected:
                if mode not in [self.ticker.MODE_LTP, self.ticker.MODE_QUOTE, self.ticker.MODE_FULL]:
                    logger.error(f"Invalid mode: {mode}")
                    return False
                
                self.ticker.set_mode(mode, tokens)
                logger.info(f"Set mode {mode} for {len(tokens)} instrument tokens")
                return True
            else:
                logger.warning("WebSocket not connected. Cannot set mode.")
                return False
        
        except Exception as e:
            logger.error(f"Failed to set mode: {e}")
            return False
    
    def get_last_price(self, symbol: str) -> Optional[float]:
        """
        Get the last price for a symbol.
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Last price if available, None otherwise
        """
        if symbol in self.latest_ticks:
            return self.latest_ticks[symbol].get('last_price')
        return None
    
    def get_last_tick(self, symbol: str) -> Optional[Dict[str, Any]]:
        """
        Get the last tick for a symbol.
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Last tick if available, None otherwise
        """
        return self.latest_ticks.get(symbol)
    
    def register_callback(self, event_type: str, callback: Callable):
        """
        Register a callback for an event type.
        
        Args:
            event_type: Event type to register callback for (on_tick, on_connect, etc.)
            callback: Callback function
            
        Returns:
            True if callback registered successfully, False otherwise
        """
        if event_type not in self.callbacks:
            logger.error(f"Invalid event type: {event_type}")
            return False
        
        self.callbacks[event_type] = callback
        logger.info(f"Registered callback for {event_type}")
        return True
    
    def _on_ticks(self, ws, ticks):
        """Callback when ticks are received."""
        for tick in ticks:
            # Get symbol for this token
            token = tick['instrument_token']
            symbol = self.token_symbol_map.get(token, str(token))
            
            # Store latest tick
            self.latest_ticks[symbol] = tick
            
            # Call user callback if registered
            if self.callbacks['on_tick']:
                self.callbacks['on_tick'](symbol, tick)
    
    def _on_connect(self, ws, response):
        """Callback when connection is established."""
        logger.info("Connected to WebSocket server")
        self.is_connected = True
        
        # Subscribe to tokens if any
        if self.subscribed_tokens:
            self.ticker.subscribe(self.subscribed_tokens)
            self.ticker.set_mode(self.ticker.MODE_FULL, self.subscribed_tokens)
            logger.info(f"Subscribed to {len(self.subscribed_tokens)} instrument tokens")
        
        # Call user callback if registered
        if self.callbacks['on_connect']:
            self.callbacks['on_connect'](response)
    
    def _on_close(self, ws, code, reason):
        """Callback when connection is closed."""
        logger.warning(f"WebSocket connection closed: {code} - {reason}")
        self.is_connected = False
        
        # Call user callback if registered
        if self.callbacks['on_close']:
            self.callbacks['on_close'](code, reason)
    
    def _on_error(self, ws, code, reason):
        """Callback when error occurs."""
        logger.error(f"WebSocket error: {code} - {reason}")
        
        # Call user callback if registered
        if self.callbacks['on_error']:
            self.callbacks['on_error'](code, reason)
    
    def _on_reconnect(self, ws, attempts_count):
        """Callback when reconnection is attempted."""
        logger.info(f"Attempting to reconnect: attempt {attempts_count}")
        
        # Call user callback if registered
        if self.callbacks['on_reconnect']:
            self.callbacks['on_reconnect'](attempts_count)
    
    def _on_noreconnect(self, ws):
        """Callback when reconnection fails after maximum retries."""
        logger.error("Failed to reconnect after maximum retries")
        
        # Call user callback if registered
        if self.callbacks['on_noreconnect']:
            self.callbacks['on_noreconnect']()
    
    def _on_order_update(self, ws, data):
        """Callback when order update is received."""
        logger.info(f"Order update received: {data.get('order_id')}")
        
        # Call user callback if registered
        if self.callbacks['on_order_update']:
            self.callbacks['on_order_update'](data)```

### ./.env

Type: Environment Configuration
Size: 4.0K
```env
# Zerodha API credentials
KITE_API_KEY='52chjymdy0tv22v5'
KITE_API_SECRET='r0cth3cnvg7tm9g3xeawzoc4d13u97wg'
KITE_ACCESS_TOKEN='8xegUAHMTQlNA6lVHNMkGem73vqOpLg6'
```

### ./execution/__init__.py

Type: Python Source Code
Size: 4.0K
```py
"""execution module for the trading system."""
"""
Execution module for trading system.

This module provides order execution functionality for the trading system,
including order placement, tracking, and inventory management.
"""

from .order_manager import OrderManager```

### ./execution/order_manager.py

Type: Python Source Code
Size: 24K
```py
"""
Order Management Module

This module handles order placement, tracking, and inventory management.
It provides functionality to place various types of orders, track their
status, and manage positions.
"""
import logging
from typing import Dict, List, Optional, Any, Union
from datetime import datetime
import time
import pandas as pd

logger = logging.getLogger(__name__)

class OrderManager:
    """
    Manages order placement, tracking, and inventory.
    
    This class handles all order-related operations including:
    - Placing different types of orders (market, limit, SL, etc.)
    - Tracking order status and history
    - Modifying and canceling orders
    - Managing positions and holdings
    """
    
    def __init__(self, kite):
        """
        Initialize the order manager.
        
        Args:
            kite: KiteConnect instance for API requests
        """
        self.kite = kite
        self.orders = {}  # Store recent orders by order_id
        self.positions = {}  # Store current positions
        self.holdings = {}  # Store current holdings
        self.trades = {}  # Store recent trades
        
        # Initialize positions and holdings
        self.refresh_positions()
        self.refresh_holdings()
    
    def place_order(
        self,
        symbol: str,
        exchange: str,
        transaction_type: str,
        quantity: int,
        product: str,
        order_type: str,
        price: Optional[float] = None,
        trigger_price: Optional[float] = None,
        validity: str = "DAY",
        disclosed_quantity: Optional[int] = None,
        tag: Optional[str] = None
    ) -> Optional[str]:
        """
        Place an order on the exchange.
        
        Args:
            symbol: Trading symbol
            exchange: Exchange (NSE, BSE, etc.)
            transaction_type: BUY or SELL
            quantity: Order quantity
            product: CNC, MIS, NRML, etc.
            order_type: MARKET, LIMIT, SL, SL-M
            price: Order price (for LIMIT orders)
            trigger_price: Trigger price (for SL and SL-M orders)
            validity: DAY or IOC
            disclosed_quantity: Disclosed quantity
            tag: Tag for the order (optional)
            
        Returns:
            Order ID if order placed successfully, None otherwise
        """
        try:
            # Map string parameters to kite constants if needed
            if transaction_type.upper() == "BUY":
                transaction_type = self.kite.TRANSACTION_TYPE_BUY
            elif transaction_type.upper() == "SELL":
                transaction_type = self.kite.TRANSACTION_TYPE_SELL
            
            if order_type.upper() == "MARKET":
                order_type = self.kite.ORDER_TYPE_MARKET
            elif order_type.upper() == "LIMIT":
                order_type = self.kite.ORDER_TYPE_LIMIT
            elif order_type.upper() == "SL":
                order_type = self.kite.ORDER_TYPE_SL
            elif order_type.upper() == "SL-M":
                order_type = self.kite.ORDER_TYPE_SLM
            
            if product.upper() == "CNC":
                product = self.kite.PRODUCT_CNC
            elif product.upper() == "MIS":
                product = self.kite.PRODUCT_MIS
            elif product.upper() == "NRML":
                product = self.kite.PRODUCT_NRML
            
            if exchange.upper() == "NSE":
                exchange = self.kite.EXCHANGE_NSE
            elif exchange.upper() == "BSE":
                exchange = self.kite.EXCHANGE_BSE
            elif exchange.upper() == "NFO":
                exchange = self.kite.EXCHANGE_NFO
            
            if validity.upper() == "DAY":
                validity = self.kite.VALIDITY_DAY
            elif validity.upper() == "IOC":
                validity = self.kite.VALIDITY_IOC
            
            # Prepare order parameters
            params = {
                "tradingsymbol": symbol,
                "exchange": exchange,
                "transaction_type": transaction_type,
                "quantity": quantity,
                "product": product,
                "order_type": order_type,
                "validity": validity
            }
            
            # Add optional parameters if provided
            if price is not None:
                params["price"] = price
            
            if trigger_price is not None:
                params["trigger_price"] = trigger_price
            
            if disclosed_quantity is not None:
                params["disclosed_quantity"] = disclosed_quantity
            
            if tag is not None:
                params["tag"] = tag
            
            # Place the order
            order_id = self.kite.place_order(
                variety=self.kite.VARIETY_REGULAR,
                **params
            )
            
            logger.info(f"Order placed successfully: {order_id}")
            
            # Get the order details and store in self.orders
            self._update_order(order_id)
            
            return order_id
            
        except Exception as e:
            logger.error(f"Failed to place order: {e}")
            return None
    
    def place_market_order(
        self,
        symbol: str,
        exchange: str,
        transaction_type: str,
        quantity: int,
        product: str = "CNC",
        tag: Optional[str] = None
    ) -> Optional[str]:
        """
        Place a market order.
        
        Args:
            symbol: Trading symbol
            exchange: Exchange (NSE, BSE, etc.)
            transaction_type: BUY or SELL
            quantity: Order quantity
            product: CNC, MIS, NRML, etc.
            tag: Tag for the order (optional)
            
        Returns:
            Order ID if order placed successfully, None otherwise
        """
        return self.place_order(
            symbol=symbol,
            exchange=exchange,
            transaction_type=transaction_type,
            quantity=quantity,
            product=product,
            order_type="MARKET",
            tag=tag
        )
    
    def place_limit_order(
        self,
        symbol: str,
        exchange: str,
        transaction_type: str,
        quantity: int,
        price: float,
        product: str = "CNC",
        tag: Optional[str] = None
    ) -> Optional[str]:
        """
        Place a limit order.
        
        Args:
            symbol: Trading symbol
            exchange: Exchange (NSE, BSE, etc.)
            transaction_type: BUY or SELL
            quantity: Order quantity
            price: Order price
            product: CNC, MIS, NRML, etc.
            tag: Tag for the order (optional)
            
        Returns:
            Order ID if order placed successfully, None otherwise
        """
        return self.place_order(
            symbol=symbol,
            exchange=exchange,
            transaction_type=transaction_type,
            quantity=quantity,
            product=product,
            order_type="LIMIT",
            price=price,
            tag=tag
        )
    
    def place_sl_order(
        self,
        symbol: str,
        exchange: str,
        transaction_type: str,
        quantity: int,
        price: float,
        trigger_price: float,
        product: str = "CNC",
        tag: Optional[str] = None
    ) -> Optional[str]:
        """
        Place a stop-loss (SL) order.
        
        Args:
            symbol: Trading symbol
            exchange: Exchange (NSE, BSE, etc.)
            transaction_type: BUY or SELL
            quantity: Order quantity
            price: Order price
            trigger_price: Trigger price
            product: CNC, MIS, NRML, etc.
            tag: Tag for the order (optional)
            
        Returns:
            Order ID if order placed successfully, None otherwise
        """
        return self.place_order(
            symbol=symbol,
            exchange=exchange,
            transaction_type=transaction_type,
            quantity=quantity,
            product=product,
            order_type="SL",
            price=price,
            trigger_price=trigger_price,
            tag=tag
        )
    
    def place_slm_order(
        self,
        symbol: str,
        exchange: str,
        transaction_type: str,
        quantity: int,
        trigger_price: float,
        product: str = "CNC",
        tag: Optional[str] = None
    ) -> Optional[str]:
        """
        Place a stop-loss market (SL-M) order.
        
        Args:
            symbol: Trading symbol
            exchange: Exchange (NSE, BSE, etc.)
            transaction_type: BUY or SELL
            quantity: Order quantity
            trigger_price: Trigger price
            product: CNC, MIS, NRML, etc.
            tag: Tag for the order (optional)
            
        Returns:
            Order ID if order placed successfully, None otherwise
        """
        return self.place_order(
            symbol=symbol,
            exchange=exchange,
            transaction_type=transaction_type,
            quantity=quantity,
            product=product,
            order_type="SL-M",
            trigger_price=trigger_price,
            tag=tag
        )
    
    def modify_order(
        self,
        order_id: str,
        quantity: Optional[int] = None,
        price: Optional[float] = None,
        order_type: Optional[str] = None,
        trigger_price: Optional[float] = None,
        validity: Optional[str] = None,
        disclosed_quantity: Optional[int] = None
    ) -> Optional[str]:
        """
        Modify an existing order.
        
        Args:
            order_id: Order ID to modify
            quantity: New quantity
            price: New price
            order_type: New order type
            trigger_price: New trigger price
            validity: New validity
            disclosed_quantity: New disclosed quantity
            
        Returns:
            Order ID if order modified successfully, None otherwise
        """
        try:
            # Map string parameters to kite constants if needed
            if order_type:
                if order_type.upper() == "MARKET":
                    order_type = self.kite.ORDER_TYPE_MARKET
                elif order_type.upper() == "LIMIT":
                    order_type = self.kite.ORDER_TYPE_LIMIT
                elif order_type.upper() == "SL":
                    order_type = self.kite.ORDER_TYPE_SL
                elif order_type.upper() == "SL-M":
                    order_type = self.kite.ORDER_TYPE_SLM
            
            if validity:
                if validity.upper() == "DAY":
                    validity = self.kite.VALIDITY_DAY
                elif validity.upper() == "IOC":
                    validity = self.kite.VALIDITY_IOC
            
            # Prepare parameters
            params = {}
            
            if quantity is not None:
                params["quantity"] = quantity
            
            if price is not None:
                params["price"] = price
            
            if order_type is not None:
                params["order_type"] = order_type
            
            if trigger_price is not None:
                params["trigger_price"] = trigger_price
            
            if validity is not None:
                params["validity"] = validity
            
            if disclosed_quantity is not None:
                params["disclosed_quantity"] = disclosed_quantity
            
            # Modify the order
            modified_order_id = self.kite.modify_order(
                variety=self.kite.VARIETY_REGULAR,
                order_id=order_id,
                **params
            )
            
            logger.info(f"Order modified successfully: {modified_order_id}")
            
            # Get the order details and store in self.orders
            self._update_order(modified_order_id)
            
            return modified_order_id
            
        except Exception as e:
            logger.error(f"Failed to modify order: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """
        Cancel an order.
        
        Args:
            order_id: Order ID to cancel
            
        Returns:
            True if order cancelled successfully, False otherwise
        """
        try:
            # Cancel the order
            self.kite.cancel_order(
                variety=self.kite.VARIETY_REGULAR,
                order_id=order_id
            )
            
            logger.info(f"Order cancelled successfully: {order_id}")
            
            # Update the order status
            self._update_order(order_id)
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to cancel order: {e}")
            return False
    
    def get_order_status(self, order_id: str) -> Optional[Dict[str, Any]]:
        """
        Get the status of an order.
        
        Args:
            order_id: Order ID to check
            
        Returns:
            Order details if found, None otherwise
        """
        try:
            # Update the order first
            self._update_order(order_id)
            
            # Return from local cache
            return self.orders.get(order_id)
            
        except Exception as e:
            logger.error(f"Failed to get order status: {e}")
            return None
    
    def get_orders(self) -> List[Dict[str, Any]]:
        """
        Get all orders for the day.
        
        Returns:
            List of orders
        """
        try:
            # Get all orders
            orders = self.kite.orders()
            
            # Update local cache
            for order in orders:
                order_id = order['order_id']
                self.orders[order_id] = order
            
            return orders
            
        except Exception as e:
            logger.error(f"Failed to get orders: {e}")
            return []
    
    def get_trades(self) -> List[Dict[str, Any]]:
        """
        Get all trades for the day.
        
        Returns:
            List of trades
        """
        try:
            # Get all trades
            trades = self.kite.trades()
            
            # Update local cache
            for trade in trades:
                trade_id = trade['trade_id']
                self.trades[trade_id] = trade
            
            return trades
            
        except Exception as e:
            logger.error(f"Failed to get trades: {e}")
            return []
    
    def refresh_positions(self) -> Dict[str, Any]:
        """
        Refresh positions from the exchange.
        
        Returns:
            Dictionary with position details
        """
        try:
            # Get all positions
            positions = self.kite.positions()
            
            # Update local cache
            self.positions = positions
            
            return positions
            
        except Exception as e:
            logger.error(f"Failed to refresh positions: {e}")
            return {}
    
    def refresh_holdings(self) -> List[Dict[str, Any]]:
        """
        Refresh holdings from the exchange.
        
        Returns:
            List of holdings
        """
        try:
            # Get all holdings
            holdings = self.kite.holdings()
            
            # Update local cache
            self.holdings = {holding['tradingsymbol']: holding for holding in holdings}
            
            return holdings
            
        except Exception as e:
            logger.error(f"Failed to refresh holdings: {e}")
            return []
    
    def get_position(self, symbol: str, exchange: str = "NSE") -> Optional[Dict[str, Any]]:
        """
        Get position for a symbol.
        
        Args:
            symbol: Trading symbol
            exchange: Exchange (NSE, BSE, etc.)
            
        Returns:
            Position details if found, None otherwise
        """
        # Refresh positions first
        self.refresh_positions()
        
        # Check for day positions
        day_positions = self.positions.get('day', [])
        for position in day_positions:
            if position['tradingsymbol'] == symbol and position['exchange'] == exchange:
                return position
        
        # Check for net positions
        net_positions = self.positions.get('net', [])
        for position in net_positions:
            if position['tradingsymbol'] == symbol and position['exchange'] == exchange:
                return position
        
        return None
    
    def get_holding(self, symbol: str) -> Optional[Dict[str, Any]]:
        """
        Get holding for a symbol.
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Holding details if found, None otherwise
        """
        # Refresh holdings first
        self.refresh_holdings()
        
        # Return from local cache
        return self.holdings.get(symbol)
    
    def wait_for_order_completion(self, order_id: str, timeout: int = 60) -> Optional[Dict[str, Any]]:
        """
        Wait for an order to complete.
        
        Args:
            order_id: Order ID to wait for
            timeout: Timeout in seconds
            
        Returns:
            Order details if completed, None if timed out or error
        """
        start_time = time.time()
        
        while True:
            # Check if timeout has been reached
            if time.time() - start_time > timeout:
                logger.warning(f"Timed out waiting for order completion: {order_id}")
                return None
            
            # Get order status
            order = self.get_order_status(order_id)
            
            if not order:
                logger.error(f"Failed to get order status: {order_id}")
                return None
            
            # Check if order is complete
            if order['status'] in ['COMPLETE', 'REJECTED', 'CANCELLED']:
                return order
            
            # Wait before checking again
            time.sleep(1)
    
    def get_positions_as_dataframe(self) -> pd.DataFrame:
        """
        Get all positions as a pandas DataFrame.
        
        Returns:
            DataFrame with position details
        """
        # Refresh positions first
        self.refresh_positions()
        
        # Combine day and net positions
        day_positions = self.positions.get('day', [])
        net_positions = self.positions.get('net', [])
        
        # Convert to DataFrame
        if day_positions or net_positions:
            df = pd.DataFrame(day_positions + net_positions)
            return df
        else:
            return pd.DataFrame()
    
    def get_holdings_as_dataframe(self) -> pd.DataFrame:
        """
        Get all holdings as a pandas DataFrame.
        
        Returns:
            DataFrame with holding details
        """
        # Refresh holdings first
        self.refresh_holdings()
        
        # Convert to DataFrame
        if self.holdings:
            df = pd.DataFrame(list(self.holdings.values()))
            return df
        else:
            return pd.DataFrame()
    
    def get_order_history(self, order_id: str) -> List[Dict[str, Any]]:
        """
        Get the history of an order.
        
        Args:
            order_id: Order ID to get history for
            
        Returns:
            List of order history
        """
        try:
            # Get order history
            history = self.kite.order_history(order_id)
            
            # Update local cache with the latest status
            if history:
                self.orders[order_id] = history[-1]
            
            return history
            
        except Exception as e:
            logger.error(f"Failed to get order history: {e}")
            return []
    
    def _update_order(self, order_id: str) -> None:
        """
        Update the local order cache for an order.
        
        Args:
            order_id: Order ID to update
        """
        try:
            # Get order history
            history = self.kite.order_history(order_id)
            
            # Update local cache with the latest status
            if history:
                self.orders[order_id] = history[-1]
                
        except Exception as e:
            logger.error(f"Failed to update order: {e}")
    
    def place_gtt_order(
        self,
        symbol: str,
        exchange: str,
        trigger_type: str,
        trigger_values: List[float],
        last_price: float,
        orders: List[Dict[str, Any]]
    ) -> Optional[str]:
        """
        Place a GTT (Good Till Triggered) order.
        
        Args:
            symbol: Trading symbol
            exchange: Exchange (NSE, BSE, etc.)
            trigger_type: single or two-leg
            trigger_values: List of trigger values
            last_price: Last price
            orders: List of orders
            
        Returns:
            Trigger ID if order placed successfully, None otherwise
        """
        try:
            # Map trigger type
            if trigger_type.lower() == "single":
                trigger_type = self.kite.GTT_TYPE_SINGLE
            elif trigger_type.lower() == "two-leg" or trigger_type.lower() == "oco":
                trigger_type = self.kite.GTT_TYPE_OCO
            
            # Map exchange
            if exchange.upper() == "NSE":
                exchange = self.kite.EXCHANGE_NSE
            elif exchange.upper() == "BSE":
                exchange = self.kite.EXCHANGE_BSE
            
            # Place GTT order
            trigger_id = self.kite.place_gtt(
                trigger_type=trigger_type,
                tradingsymbol=symbol,
                exchange=exchange,
                trigger_values=trigger_values,
                last_price=last_price,
                orders=orders
            )
            
            logger.info(f"GTT order placed successfully: {trigger_id}")
            
            return trigger_id
            
        except Exception as e:
            logger.error(f"Failed to place GTT order: {e}")
            return None
    
    def get_gtt_orders(self) -> List[Dict[str, Any]]:
        """
        Get all GTT orders.
        
        Returns:
            List of GTT orders
        """
        try:
            # Get all GTT orders
            gtt_orders = self.kite.get_gtts()
            
            return gtt_orders
            
        except Exception as e:
            logger.error(f"Failed to get GTT orders: {e}")
            return []
    
    def cancel_gtt_order(self, trigger_id: str) -> bool:
        """
        Cancel a GTT order.
        
        Args:
            trigger_id: Trigger ID to cancel
            
        Returns:
            True if order cancelled successfully, False otherwise
        """
        try:
            # Cancel the GTT order
            self.kite.delete_gtt(trigger_id)
            
            logger.info(f"GTT order cancelled successfully: {trigger_id}")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to cancel GTT order: {e}")
            return False```

### ./fetch_historical_data.py

Type: Python Source Code
Size: 8.0K
```py
#!/usr/bin/env python
"""
Script to fetch historical data for backtesting.

This script fetches historical price data for specified symbols
and saves it to CSV files for later use.

Usage:
    python fetch_historical_data.py --symbols RELIANCE TCS INFY --days 365 --interval day --plot
"""
import os
import sys
import argparse
import logging
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
from dotenv import load_dotenv

# Import our modules
from auth.zerodha_auth import ZerodhaAuth
from data.historical_data import HistoricalDataManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="Fetch and manage historical market data")
    
    parser.add_argument(
        "--symbols", 
        type=str, 
        nargs="+", 
        default=["RELIANCE", "TCS", "INFY", "HDFCBANK", "ICICIBANK"],
        help="List of trading symbols"
    )
    
    parser.add_argument(
        "--days", 
        type=int, 
        default=365,
        help="Number of days of historical data to fetch"
    )
    
    parser.add_argument(
        "--interval", 
        type=str, 
        default="day",
        choices=["minute", "3minute", "5minute", "10minute", "15minute", "30minute", "60minute", "day"],
        help="Candle interval for historical data"
    )
    
    parser.add_argument(
        "--exchange", 
        type=str, 
        default="NSE",
        choices=["NSE", "BSE", "NFO", "BFO", "CDS", "MCX"],
        help="Exchange to fetch data from"
    )
    
    parser.add_argument(
        "--plot", 
        action="store_true",
        help="Plot the fetched data"
    )
    
    parser.add_argument(
        "--data-dir", 
        type=str, 
        default="data/historical",
        help="Directory to store historical data"
    )
    
    return parser.parse_args()

def plot_data(data_manager, symbols, data):
    """Plot historical price data."""
    if len(symbols) == 1:
        symbol = symbols[0]
        df = data.get(symbol)
        if df is not None:
            plt.figure(figsize=(12, 6))
            plt.plot(df.index, df['close'], label=f"{symbol} Close Price")
            
            plt.title(f"{symbol} Historical Price Data")
            plt.xlabel("Date")
            plt.ylabel("Price (₹)")
            plt.legend()
            plt.grid(True)
            plt.tight_layout()
            plt.show()
    else:
        # Plot multiple symbols (normalized to 100)
        plt.figure(figsize=(12, 6))
        
        for symbol, df in data.items():
            if df is not None and not df.empty:
                # Normalize to 100 at the start
                prices = df['close'] / df['close'].iloc[0] * 100
                plt.plot(df.index, prices, label=f"{symbol}")
        
        plt.title("Historical Price Data (Normalized)")
        plt.xlabel("Date")
        plt.ylabel("Price (Normalized to 100)")
        plt.legend()
        plt.grid(True)
        plt.tight_layout()
        plt.show()

def main():
    """Main function."""
    # Parse command line arguments
    args = parse_arguments()
    
    # Load environment variables
    load_dotenv()
    
    # Get API key, secret, and access token from environment variables
    api_key = os.getenv("KITE_API_KEY")
    api_secret = os.getenv("KITE_API_SECRET")
    access_token = os.getenv("KITE_ACCESS_TOKEN")
    
    if not api_key or not api_secret or not access_token:
        logger.error("API key, secret, and access token are required")
        logger.error("Please run the authentication script first")
        sys.exit(1)
    
    # Initialize ZerodhaAuth
    try:
        auth = ZerodhaAuth(api_key, api_secret, access_token)
        
        # Validate connection
        if not auth.validate_connection():
            logger.error("Connection validation failed. Your access token may be expired.")
            logger.error("Please run the authentication script again to get a new access token.")
            sys.exit(1)
            
        logger.info("Authentication successful")
        
        # Get KiteConnect instance
        kite = auth.get_kite()
    except Exception as e:
        logger.error(f"Authentication failed: {e}")
        sys.exit(1)
    
    # Calculate date range
    to_date = datetime.now()
    from_date = to_date - timedelta(days=args.days)
    
    # Convert to string format required by API
    from_date_str = from_date.strftime('%Y-%m-%d')
    to_date_str = to_date.strftime('%Y-%m-%d')
    
    # Initialize HistoricalDataManager
    data_manager = HistoricalDataManager(kite, args.data_dir)
    
    # Fetch historical data
    logger.info(f"Fetching {args.days} days of historical data for {len(args.symbols)} symbols...")
    data = data_manager.fetch_multiple_symbols(
        args.symbols, 
        from_date_str, 
        to_date_str, 
        args.interval, 
        args.exchange
    )
    
    # Print summary
    print("\n" + "="*80)
    print("HISTORICAL DATA SUMMARY")
    print("="*80)
    
    for symbol, df in data.items():
        print(f"{symbol}: {len(df)} {args.interval}-candles from {df.index.min()} to {df.index.max()}")
    
    # Plot data if requested
    if args.plot:
        plot_data(data_manager, args.symbols, data)
    
    print("\nHistorical data fetched and saved successfully!")

if __name__ == "__main__":
    main()```

### ./__init__.py

Type: Python Source Code
Size: 4.0K
```py
"""Trading system package."""
__version__ = "0.1.0"
```

### ./README.md

Type: Markdown Documentation
Size: 4.0K
```md
# Trading System

An automated trading system for Indian markets using Zerodha's Kite API.

## Setup

1. Clone the repository
2. Install dependencies: `pip install -r requirements.txt`
3. Configure your API keys in `.env`
4. Run authentication: `python authenticate.py`

## Components

- Backtesting
- Paper Trading
- Live Trading
- Strategy Optimization
```

### ./risk/__init__.py

Type: Python Source Code
Size: 4.0K
```py
"""risk module for the trading system."""
```

### ./risk/risk_manager.py

Type: Python Source Code
Size: 0
```py
```

### ./run_backtest.py

Type: Python Source Code
Size: 0
```py
```

### ./run_live_trading.py

Type: Python Source Code
Size: 0
```py
```

### ./run_optimization.py

Type: Python Source Code
Size: 0
```py
```

### ./run_paper_trading.py

Type: Python Source Code
Size: 0
```py
```

### ./setup.py

Type: Python Source Code
Size: 4.0K
```py
from setuptools import setup, find_packages

setup(
    name="trading_system",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        "python-dateutil",
        "pandas",
        "numpy",
        "matplotlib",
    ],
)
```

### ./strategy/base_strategy.py

Type: Python Source Code
Size: 0
```py
```

### ./strategy/__init__.py

Type: Python Source Code
Size: 4.0K
```py
"""strategy module for the trading system."""
```

### ./strategy/moving_average.py

Type: Python Source Code
Size: 0
```py
```

### ./strategy/rsi_strategy.py

Type: Python Source Code
Size: 0
```py
```

### ./system.py

Type: Python Source Code
Size: 0
```py
```

### ./test_setup.py

Type: Python Source Code
Size: 4.0K
```py
from kiteconnect import KiteConnect

kite = KiteConnect(api_key="your_api_key")
print(kite.login_url())```

### ./tests/__init__.py

Type: Python Source Code
Size: 4.0K
```py
"""Test package for trading system."""
```

### ./tests/test_auth.py

Type: Python Source Code
Size: 0
```py
```

### ./tests/test_data.py

Type: Python Source Code
Size: 12K
```py
"""
Tests for the data module of the trading system.
"""
import os
import unittest
import pandas as pd
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch

from data.historical_data import HistoricalDataManager

class TestHistoricalDataManager(unittest.TestCase):
    """Tests for the HistoricalDataManager class."""
    
    def setUp(self):
        """Set up the test environment."""
        # Create a mock KiteConnect instance
        self.mock_kite = MagicMock()
        
        # Set up a test data directory
        self.test_data_dir = "tests/test_data"
        os.makedirs(self.test_data_dir, exist_ok=True)
        
        # Create an instance of HistoricalDataManager with mock KiteConnect
        self.data_manager = HistoricalDataManager(self.mock_kite, self.test_data_dir)
        
        # Sample data for testing
        self.sample_data = [
            {
                "date": "2023-01-01 09:15:00",
                "open": 100.0,
                "high": 105.0,
                "low": 99.0,
                "close": 102.0,
                "volume": 1000
            },
            {
                "date": "2023-01-02 09:15:00",
                "open": 102.0,
                "high": 107.0,
                "low": 101.0,
                "close": 106.0,
                "volume": 1200
            },
            {
                "date": "2023-01-03 09:15:00",
                "open": 106.0,
                "high": 110.0,
                "low": 105.0,
                "close": 108.0,
                "volume": 1500
            }
        ]
        
        # Sample instruments data
        self.sample_instruments = [
            {
                "instrument_token": 12345,
                "exchange_token": 123,
                "tradingsymbol": "RELIANCE",
                "name": "RELIANCE INDUSTRIES LTD",
                "exchange": "NSE"
            },
            {
                "instrument_token": 67890,
                "exchange_token": 678,
                "tradingsymbol": "TCS",
                "name": "TATA CONSULTANCY SERVICES LTD",
                "exchange": "NSE"
            }
        ]
    
    def tearDown(self):
        """Clean up after the test."""
        # Remove test files
        for filename in os.listdir(self.test_data_dir):
            if filename.endswith(".csv"):
                os.remove(os.path.join(self.test_data_dir, filename))
        
        # Try to remove test directory
        try:
            os.rmdir(self.test_data_dir)
        except OSError:
            pass  # Directory not empty or doesn't exist
    
    def test_initialization(self):
        """Test initialization of HistoricalDataManager."""
        # Check if the data directory is created
        self.assertTrue(os.path.exists(self.test_data_dir))
        
        # Check if the instrument_tokens attribute is initialized as an empty dict
        self.assertEqual(self.data_manager.instrument_tokens, {})
    
    def test_get_instrument_tokens(self):
        """Test getting instrument tokens."""
        # Set up mock return value for kite.instruments
        self.mock_kite.instruments.return_value = self.sample_instruments
        
        # Call the method
        tokens = self.data_manager.get_instrument_tokens(["RELIANCE", "TCS"])
        
        # Check if the mock was called correctly
        self.mock_kite.instruments.assert_called_once_with("NSE")
        
        # Check the result
        self.assertEqual(tokens, {"RELIANCE": 12345, "TCS": 67890})
        
        # Check if instrument_tokens attribute is updated
        self.assertEqual(self.data_manager.instrument_tokens, {"RELIANCE": 12345, "TCS": 67890})
    
    def test_fetch_historical_data(self):
        """Test fetching historical data."""
        # Set up mock return value for kite.historical_data
        self.mock_kite.historical_data.return_value = self.sample_data
        
        # Call the method
        from_date = "2023-01-01"
        to_date = "2023-01-03"
        df = self.data_manager.fetch_historical_data(12345, from_date, to_date)
        
        # Check if the mock was called correctly
        self.mock_kite.historical_data.assert_called_once_with(
            instrument_token=12345,
            from_date=from_date,
            to_date=to_date,
            interval="day"
        )
        
        # Check the result
        self.assertEqual(len(df), 3)
        self.assertIn('open', df.columns)
        self.assertIn('high', df.columns)
        self.assertIn('low', df.columns)
        self.assertIn('close', df.columns)
        self.assertIn('volume', df.columns)
    
    def test_save_and_load_data(self):
        """Test saving and loading data."""
        # Create a test DataFrame
        df = pd.DataFrame(self.sample_data)
        df['date'] = pd.to_datetime(df['date'])
        df.set_index('date', inplace=True)
        
        # Save the data
        symbol = "TESTDATA"
        self.data_manager.save_data(symbol, df)
        
        # Check if the file was created
        filename = os.path.join(self.test_data_dir, f"{symbol}.csv")
        self.assertTrue(os.path.exists(filename))
        
        # Load the data
        loaded_df = self.data_manager.load_data(symbol)
        
        # Check if the loaded data matches the original
        pd.testing.assert_frame_equal(df, loaded_df)
    
    def test_fetch_multiple_symbols(self):
        """Test fetching data for multiple symbols."""
        # Set up mock return values
        self.mock_kite.instruments.return_value = self.sample_instruments
        self.mock_kite.historical_data.return_value = self.sample_data
        
        # Call the method
        from_date = "2023-01-01"
        to_date = "2023-01-03"
        data = self.data_manager.fetch_multiple_symbols(["RELIANCE", "TCS"], from_date, to_date)
        
        # Check if the mocks were called correctly
        self.mock_kite.instruments.assert_called_once_with("NSE")
        self.assertEqual(self.mock_kite.historical_data.call_count, 2)
        
        # Check the result
        self.assertEqual(len(data), 2)
        self.assertIn("RELIANCE", data)
        self.assertIn("TCS", data)
        
        # Check if data was saved
        self.assertTrue(os.path.exists(os.path.join(self.test_data_dir, "RELIANCE.csv")))
        self.assertTrue(os.path.exists(os.path.join(self.test_data_dir, "TCS.csv")))
    
    def test_load_multiple_symbols(self):
        """Test loading data for multiple symbols."""
        # Create and save test DataFrames
        df = pd.DataFrame(self.sample_data)
        df['date'] = pd.to_datetime(df['date'])
        df.set_index('date', inplace=True)
        
        symbols = ["SYMBOL1", "SYMBOL2"]
        for symbol in symbols:
            self.data_manager.save_data(symbol, df)
        
        # Load the data
        loaded_data = self.data_manager.load_multiple_symbols(symbols)
        
        # Check the result
        self.assertEqual(len(loaded_data), 2)
        self.assertIn("SYMBOL1", loaded_data)
        self.assertIn("SYMBOL2", loaded_data)
        
        # Check if the loaded data matches the original
        for symbol in symbols:
            pd.testing.assert_frame_equal(df, loaded_data[symbol])
    
    def test_get_latest_data(self):
        """Test getting the latest data for a symbol."""
        # Create a test DataFrame with 100 days of data
        dates = [datetime.now() - timedelta(days=i) for i in range(100)]
        dates.reverse()  # Oldest to newest
        
        data = []
        for i, date in enumerate(dates):
            data.append({
                "date": date,
                "open": 100 + i,
                "high": 105 + i,
                "low": 99 + i,
                "close": 102 + i,
                "volume": 1000 + i * 10
            })
        
        df = pd.DataFrame(data)
        df.set_index('date', inplace=True)
        
        # Save the data
        symbol = "TESTLATEST"
        self.data_manager.save_data(symbol, df)
        
        # Get the latest 30 days of data
        latest_df = self.data_manager.get_latest_data(symbol, days=30)
        
        # Check the result
        self.assertEqual(len(latest_df), 30)
        self.assertEqual(latest_df.iloc[-1]['close'], 102 + 99)  # Last day's close
        self.assertEqual(latest_df.iloc[0]['close'], 102 + 70)  # First day of the 30 days

if __name__ == '__main__':
    unittest.main()```

### ./tests/test_execution.py

Type: Python Source Code
Size: 20K
```py
"""
Tests for the execution module of the trading system.
"""
import unittest
from unittest.mock import MagicMock, patch

from execution.order_manager import OrderManager

class TestOrderManager(unittest.TestCase):
    """Tests for the OrderManager class."""
    
    def setUp(self):
        """Set up the test environment."""
        # Mock KiteConnect instance
        self.mock_kite = MagicMock()
        
        # Set up constants on mock kite
        self.mock_kite.TRANSACTION_TYPE_BUY = "BUY"
        self.mock_kite.TRANSACTION_TYPE_SELL = "SELL"
        self.mock_kite.ORDER_TYPE_MARKET = "MARKET"
        self.mock_kite.ORDER_TYPE_LIMIT = "LIMIT"
        self.mock_kite.ORDER_TYPE_SL = "SL"
        self.mock_kite.ORDER_TYPE_SLM = "SL-M"
        self.mock_kite.PRODUCT_CNC = "CNC"
        self.mock_kite.PRODUCT_MIS = "MIS"
        self.mock_kite.PRODUCT_NRML = "NRML"
        self.mock_kite.EXCHANGE_NSE = "NSE"
        self.mock_kite.EXCHANGE_BSE = "BSE"
        self.mock_kite.VALIDITY_DAY = "DAY"
        self.mock_kite.VALIDITY_IOC = "IOC"
        self.mock_kite.VARIETY_REGULAR = "regular"
        self.mock_kite.GTT_TYPE_SINGLE = "single"
        self.mock_kite.GTT_TYPE_OCO = "two-leg"
        
        # Mock returns for kite methods
        self.mock_kite.orders.return_value = [
            {
                "order_id": "123456",
                "status": "COMPLETE",
                "tradingsymbol": "INFY",
                "exchange": "NSE",
                "transaction_type": "BUY",
                "quantity": 10,
                "product": "CNC",
                "order_type": "MARKET"
            }
        ]
        
        self.mock_kite.positions.return_value = {
            "day": [
                {
                    "tradingsymbol": "INFY",
                    "exchange": "NSE",
                    "product": "CNC",
                    "quantity": 10,
                    "average_price": 1000.0
                }
            ],
            "net": []
        }
        
        self.mock_kite.holdings.return_value = [
            {
                "tradingsymbol": "INFY",
                "exchange": "NSE",
                "quantity": 10,
                "average_price": 1000.0
            }
        ]
        
        self.mock_kite.trades.return_value = [
            {
                "trade_id": "987654",
                "order_id": "123456",
                "tradingsymbol": "INFY",
                "exchange": "NSE",
                "quantity": 10,
                "average_price": 1000.0
            }
        ]
        
        self.mock_kite.order_history.return_value = [
            {
                "order_id": "123456",
                "status": "OPEN"
            },
            {
                "order_id": "123456",
                "status": "COMPLETE"
            }
        ]
        
        # Create OrderManager instance
        self.order_manager = OrderManager(self.mock_kite)
    
    def test_initialization(self):
        """Test initialization of OrderManager."""
        # Check if position and holdings are refreshed during initialization
        self.mock_kite.positions.assert_called_once()
        self.mock_kite.holdings.assert_called_once()
        
        # Check if the positions and holdings are stored correctly
        self.assertEqual(len(self.order_manager.positions), 2)  # day and net
        self.assertEqual(len(self.order_manager.holdings), 1)  # one holding
        
        # Check if orders and trades dictionaries are initialized
        self.assertEqual(self.order_manager.orders, {})
        self.assertEqual(self.order_manager.trades, {})
    
    def test_place_order(self):
        """Test placing an order."""
        # Set up mock return value for place_order
        self.mock_kite.place_order.return_value = "123456"
        
        # Call the method
        order_id = self.order_manager.place_order(
            symbol="INFY",
            exchange="NSE",
            transaction_type="BUY",
            quantity=10,
            product="CNC",
            order_type="MARKET"
        )
        
        # Check if place_order was called with correct parameters
        self.mock_kite.place_order.assert_called_once_with(
            variety="regular",
            tradingsymbol="INFY",
            exchange="NSE",
            transaction_type="BUY",
            quantity=10,
            product="CNC",
            order_type="MARKET",
            validity="DAY"
        )
        
        # Check if order history was fetched
        self.mock_kite.order_history.assert_called_once_with("123456")
        
        # Check if the order was stored correctly
        self.assertEqual(self.order_manager.orders["123456"]["status"], "COMPLETE")
        
        # Check return value
        self.assertEqual(order_id, "123456")
    
    def test_place_market_order(self):
        """Test placing a market order."""
        # Set up mock return value for place_order
        self.mock_kite.place_order.return_value = "123456"
        
        # Call the method
        order_id = self.order_manager.place_market_order(
            symbol="INFY",
            exchange="NSE",
            transaction_type="BUY",
            quantity=10
        )
        
        # Check if place_order was called with correct parameters
        self.mock_kite.place_order.assert_called_once_with(
            variety="regular",
            tradingsymbol="INFY",
            exchange="NSE",
            transaction_type="BUY",
            quantity=10,
            product="CNC",
            order_type="MARKET",
            validity="DAY",
            tag=None
        )
        
        # Check return value
        self.assertEqual(order_id, "123456")
    
    def test_place_limit_order(self):
        """Test placing a limit order."""
        # Set up mock return value for place_order
        self.mock_kite.place_order.return_value = "123456"
        
        # Call the method
        order_id = self.order_manager.place_limit_order(
            symbol="INFY",
            exchange="NSE",
            transaction_type="BUY",
            quantity=10,
            price=1000.0
        )
        
        # Check if place_order was called with correct parameters
        self.mock_kite.place_order.assert_called_once_with(
            variety="regular",
            tradingsymbol="INFY",
            exchange="NSE",
            transaction_type="BUY",
            quantity=10,
            product="CNC",
            order_type="LIMIT",
            price=1000.0,
            validity="DAY",
            tag=None
        )
        
        # Check return value
        self.assertEqual(order_id, "123456")
    
    def test_place_sl_order(self):
        """Test placing a stop-loss order."""
        # Set up mock return value for place_order
        self.mock_kite.place_order.return_value = "123456"
        
        # Call the method
        order_id = self.order_manager.place_sl_order(
            symbol="INFY",
            exchange="NSE",
            transaction_type="SELL",
            quantity=10,
            price=990.0,
            trigger_price=995.0
        )
        
        # Check if place_order was called with correct parameters
        self.mock_kite.place_order.assert_called_once_with(
            variety="regular",
            tradingsymbol="INFY",
            exchange="NSE",
            transaction_type="SELL",
            quantity=10,
            product="CNC",
            order_type="SL",
            price=990.0,
            trigger_price=995.0,
            validity="DAY",
            tag=None
        )
        
        # Check return value
        self.assertEqual(order_id, "123456")
    
    def test_place_slm_order(self):
        """Test placing a stop-loss market order."""
        # Set up mock return value for place_order
        self.mock_kite.place_order.return_value = "123456"
        
        # Call the method
        order_id = self.order_manager.place_slm_order(
            symbol="INFY",
            exchange="NSE",
            transaction_type="SELL",
            quantity=10,
            trigger_price=995.0
        )
        
        # Check if place_order was called with correct parameters
        self.mock_kite.place_order.assert_called_once_with(
            variety="regular",
            tradingsymbol="INFY",
            exchange="NSE",
            transaction_type="SELL",
            quantity=10,
            product="CNC",
            order_type="SL-M",
            trigger_price=995.0,
            validity="DAY",
            tag=None
        )
        
        # Check return value
        self.assertEqual(order_id, "123456")
    
    def test_modify_order(self):
        """Test modifying an order."""
        # Set up mock return value for modify_order
        self.mock_kite.modify_order.return_value = "123456"
        
        # Call the method
        order_id = self.order_manager.modify_order(
            order_id="123456",
            quantity=20,
            price=1100.0
        )
        
        # Check if modify_order was called with correct parameters
        self.mock_kite.modify_order.assert_called_once_with(
            variety="regular",
            order_id="123456",
            quantity=20,
            price=1100.0
        )
        
        # Check return value
        self.assertEqual(order_id, "123456")
    
    def test_cancel_order(self):
        """Test cancelling an order."""
        # Call the method
        result = self.order_manager.cancel_order("123456")
        
        # Check if cancel_order was called with correct parameters
        self.mock_kite.cancel_order.assert_called_once_with(
            variety="regular",
            order_id="123456"
        )
        
        # Check return value
        self.assertTrue(result)
    
    def test_get_order_status(self):
        """Test getting order status."""
        # Call the method
        order = self.order_manager.get_order_status("123456")
        
        # Check if order_history was called with correct parameters
        self.mock_kite.order_history.assert_called_once_with("123456")
        
        # Check return value
        self.assertEqual(order["status"], "COMPLETE")
    
    def test_get_orders(self):
        """Test getting all orders."""
        # Call the method
        orders = self.order_manager.get_orders()
        
        # Check if orders was called
        self.mock_kite.orders.assert_called_once()
        
        # Check return value
        self.assertEqual(len(orders), 1)
        self.assertEqual(orders[0]["order_id"], "123456")
        
        # Check if order was stored in local cache
        self.assertEqual(self.order_manager.orders["123456"]["order_id"], "123456")
    
    def test_get_trades(self):
        """Test getting all trades."""
        # Call the method
        trades = self.order_manager.get_trades()
        
        # Check if trades was called
        self.mock_kite.trades.assert_called_once()
        
        # Check return value
        self.assertEqual(len(trades), 1)
        self.assertEqual(trades[0]["trade_id"], "987654")
        
        # Check if trade was stored in local cache
        self.assertEqual(self.order_manager.trades["987654"]["trade_id"], "987654")
    
    def test_refresh_positions(self):
        """Test refreshing positions."""
        # Reset the mock to clear the call count
        self.mock_kite.positions.reset_mock()
        
        # Call the method
        positions = self.order_manager.refresh_positions()
        
        # Check if positions was called
        self.mock_kite.positions.assert_called_once()
        
        # Check return value
        self.assertEqual(len(positions), 2)  # day and net
        self.assertEqual(positions["day"][0]["tradingsymbol"], "INFY")
    
    def test_refresh_holdings(self):
        """Test refreshing holdings."""
        # Reset the mock to clear the call count
        self.mock_kite.holdings.reset_mock()
        
        # Call the method
        holdings = self.order_manager.refresh_holdings()
        
        # Check if holdings was called
        self.mock_kite.holdings.assert_called_once()
        
        # Check return value
        self.assertEqual(len(holdings), 1)
        self.assertEqual(holdings[0]["tradingsymbol"], "INFY")
        
        # Check if holdings were stored in local cache
        self.assertEqual(self.order_manager.holdings["INFY"]["tradingsymbol"], "INFY")
    
    def test_get_position(self):
        """Test getting position for a symbol."""
        # Call the method
        position = self.order_manager.get_position("INFY", "NSE")
        
        # Check if positions was called
        self.mock_kite.positions.assert_called()
        
        # Check return value
        self.assertEqual(position["tradingsymbol"], "INFY")
        self.assertEqual(position["exchange"], "NSE")
    
    def test_get_holding(self):
        """Test getting holding for a symbol."""
        # Call the method
        holding = self.order_manager.get_holding("INFY")
        
        # Check if holdings was called
        self.mock_kite.holdings.assert_called()
        
        # Check return value
        self.assertEqual(holding["tradingsymbol"], "INFY")
    
    def test_get_order_history(self):
        """Test getting order history."""
        # Call the method
        history = self.order_manager.get_order_history("123456")
        
        # Check if order_history was called with correct parameters
        self.mock_kite.order_history.assert_called_with("123456")
        
        # Check return value
        self.assertEqual(len(history), 2)
        self.assertEqual(history[0]["status"], "OPEN")
        self.assertEqual(history[1]["status"], "COMPLETE")
        
        # Check if latest status was stored in local cache
        self.assertEqual(self.order_manager.orders["123456"]["status"], "COMPLETE")
    
    def test_place_gtt_order(self):
        """Test placing a GTT order."""
        # Set up mock return value for place_gtt
        self.mock_kite.place_gtt.return_value = "987654"
        
        # Call the method
        trigger_id = self.order_manager.place_gtt_order(
            symbol="INFY",
            exchange="NSE",
            trigger_type="single",
            trigger_values=[990.0],
            last_price=1000.0,
            orders=[
                {
                    "transaction_type": "SELL",
                    "quantity": 10,
                    "product": "CNC",
                    "order_type": "LIMIT",
                    "price": 990.0
                }
            ]
        )
        
        # Check if place_gtt was called with correct parameters
        self.mock_kite.place_gtt.assert_called_once_with(
            trigger_type="single",
            tradingsymbol="INFY",
            exchange="NSE",
            trigger_values=[990.0],
            last_price=1000.0,
            orders=[
                {
                    "transaction_type": "SELL",
                    "quantity": 10,
                    "product": "CNC",
                    "order_type": "LIMIT",
                    "price": 990.0
                }
            ]
        )
        
        # Check return value
        self.assertEqual(trigger_id, "987654")
    
    def test_get_gtt_orders(self):
        """Test getting all GTT orders."""
        # Set up mock return value for get_gtts
        self.mock_kite.get_gtts.return_value = [
            {
                "id": "987654",
                "type": "single",
                "tradingsymbol": "INFY",
                "exchange": "NSE",
                "trigger_values": [990.0],
                "last_price": 1000.0,
                "orders": [
                    {
                        "transaction_type": "SELL",
                        "quantity": 10,
                        "product": "CNC",
                        "order_type": "LIMIT",
                        "price": 990.0
                    }
                ]
            }
        ]
        
        # Call the method
        gtt_orders = self.order_manager.get_gtt_orders()
        
        # Check if get_gtts was called
        self.mock_kite.get_gtts.assert_called_once()
        
        # Check return value
        self.assertEqual(len(gtt_orders), 1)
        self.assertEqual(gtt_orders[0]["id"], "987654")
    
    def test_cancel_gtt_order(self):
        """Test cancelling a GTT order."""
        # Call the method
        result = self.order_manager.cancel_gtt_order("987654")
        
        # Check if delete_gtt was called with correct parameters
        self.mock_kite.delete_gtt.assert_called_once_with("987654")
        
        # Check return value
        self.assertTrue(result)

if __name__ == '__main__':
    unittest.main()```

### ./tests/test_realtime_data.py

Type: Python Source Code
Size: 12K
```py
"""
Tests for the real-time data module of the trading system.
"""
import unittest
from unittest.mock import MagicMock, patch

from data.realtime_data import RealTimeDataManager

class TestRealTimeDataManager(unittest.TestCase):
    """Tests for the RealTimeDataManager class."""
    
    def setUp(self):
        """Set up the test environment."""
        # Mock API credentials
        self.api_key = "test_api_key"
        self.access_token = "test_access_token"
        
        # Create an instance of RealTimeDataManager
        self.realtime_manager = RealTimeDataManager(self.api_key, self.access_token)
        
        # Set up mock for KiteTicker
        self.mock_ticker = MagicMock()
        
        # Define test data
        self.test_tokens = [12345, 67890]
        self.test_token_symbol_map = {12345: "RELIANCE", 67890: "TCS"}
        self.test_symbol_token_map = {"RELIANCE": 12345, "TCS": 67890}
        self.test_tick = {
            'instrument_token': 12345,
            'last_price': 2500.0,
            'volume': 1000,
            'depth': {'buy': [], 'sell': []},
            'timestamp': '2023-05-01 09:15:00'
        }
    
    def test_initialization(self):
        """Test initialization of RealTimeDataManager."""
        # Check if instance variables are initialized correctly
        self.assertEqual(self.realtime_manager.api_key, self.api_key)
        self.assertEqual(self.realtime_manager.access_token, self.access_token)
        self.assertIsNone(self.realtime_manager.ticker)
        self.assertFalse(self.realtime_manager.is_connected)
        self.assertEqual(self.realtime_manager.subscribed_tokens, [])
        self.assertEqual(self.realtime_manager.token_symbol_map, {})
        self.assertEqual(self.realtime_manager.symbol_token_map, {})
        self.assertEqual(self.realtime_manager.latest_ticks, {})
        
        # Check if callbacks are initialized to None
        for callback_type in ['on_tick', 'on_connect', 'on_close', 'on_error', 'on_reconnect', 'on_noreconnect', 'on_order_update']:
            self.assertIsNone(self.realtime_manager.callbacks[callback_type])
    
    @patch('data.realtime_data.KiteTicker')
    def test_start(self, mock_kite_ticker):
        """Test starting the WebSocket connection."""
        # Set up mock KiteTicker instance
        mock_kite_ticker.return_value = self.mock_ticker
        
        # Call the method
        result = self.realtime_manager.start()
        
        # Check if KiteTicker was initialized correctly
        mock_kite_ticker.assert_called_once_with(self.api_key, self.access_token)
        
        # Check if callbacks were set up
        self.assertIsNotNone(self.mock_ticker.on_ticks)
        self.assertIsNotNone(self.mock_ticker.on_connect)
        self.assertIsNotNone(self.mock_ticker.on_close)
        self.assertIsNotNone(self.mock_ticker.on_error)
        self.assertIsNotNone(self.mock_ticker.on_reconnect)
        self.assertIsNotNone(self.mock_ticker.on_noreconnect)
        self.assertIsNotNone(self.mock_ticker.on_order_update)
        
        # Check if connect was called
        self.mock_ticker.connect.assert_called_once_with(threaded=True)
        
        # Check return value
        self.assertTrue(result)
    
    def test_stop(self):
        """Test stopping the WebSocket connection."""
        # Set up mock ticker
        self.realtime_manager.ticker = self.mock_ticker
        self.realtime_manager.is_connected = True
        
        # Call the method
        result = self.realtime_manager.stop()
        
        # Check if close was called
        self.mock_ticker.close.assert_called_once()
        
        # Check if instance variables were updated
        self.assertIsNone(self.realtime_manager.ticker)
        self.assertFalse(self.realtime_manager.is_connected)
        
        # Check return value
        self.assertTrue(result)
    
    def test_subscribe(self):
        """Test subscribing to instrument tokens."""
        # Set up mock ticker
        self.realtime_manager.ticker = self.mock_ticker
        self.realtime_manager.is_connected = True
        
        # Call the method
        result = self.realtime_manager.subscribe(
            self.test_tokens,
            self.test_token_symbol_map,
            self.test_symbol_token_map
        )
        
        # Check if instance variables were updated
        self.assertEqual(self.realtime_manager.subscribed_tokens, self.test_tokens)
        self.assertEqual(self.realtime_manager.token_symbol_map, self.test_token_symbol_map)
        self.assertEqual(self.realtime_manager.symbol_token_map, self.test_symbol_token_map)
        
        # Check if subscribe was called
        self.mock_ticker.subscribe.assert_called_once_with(self.test_tokens)
        
        # Check if set_mode was called
        self.mock_ticker.set_mode.assert_called_once()
        
        # Check return value
        self.assertTrue(result)
    
    def test_unsubscribe(self):
        """Test unsubscribing from instrument tokens."""
        # Set up mock ticker and instance variables
        self.realtime_manager.ticker = self.mock_ticker
        self.realtime_manager.is_connected = True
        self.realtime_manager.subscribed_tokens = self.test_tokens
        self.realtime_manager.token_symbol_map = self.test_token_symbol_map
        self.realtime_manager.latest_ticks = {"RELIANCE": self.test_tick}
        
        # Call the method
        result = self.realtime_manager.unsubscribe([12345])
        
        # Check if unsubscribe was called
        self.mock_ticker.unsubscribe.assert_called_once_with([12345])
        
        # Check if instance variables were updated
        self.assertEqual(self.realtime_manager.subscribed_tokens, [67890])
        
        # Check if latest_ticks was updated
        self.assertNotIn("RELIANCE", self.realtime_manager.latest_ticks)
        
        # Check return value
        self.assertTrue(result)
    
    def test_set_mode(self):
        """Test setting mode for instrument tokens."""
        # Set up mock ticker
        self.realtime_manager.ticker = self.mock_ticker
        self.realtime_manager.is_connected = True
        
        # Define modes
        self.mock_ticker.MODE_LTP = "ltp"
        self.mock_ticker.MODE_QUOTE = "quote"
        self.mock_ticker.MODE_FULL = "full"
        
        # Call the method
        result = self.realtime_manager.set_mode("full", self.test_tokens)
        
        # Check if set_mode was called
        self.mock_ticker.set_mode.assert_called_once_with("full", self.test_tokens)
        
        # Check return value
        self.assertTrue(result)
    
    def test_get_last_price(self):
        """Test getting last price for a symbol."""
        # Set up instance variables
        self.realtime_manager.latest_ticks = {"RELIANCE": self.test_tick}
        
        # Call the method
        price = self.realtime_manager.get_last_price("RELIANCE")
        
        # Check return value
        self.assertEqual(price, 2500.0)
        
        # Test for non-existent symbol
        price = self.realtime_manager.get_last_price("NONEXISTENT")
        self.assertIsNone(price)
    
    def test_get_last_tick(self):
        """Test getting last tick for a symbol."""
        # Set up instance variables
        self.realtime_manager.latest_ticks = {"RELIANCE": self.test_tick}
        
        # Call the method
        tick = self.realtime_manager.get_last_tick("RELIANCE")
        
        # Check return value
        self.assertEqual(tick, self.test_tick)
        
        # Test for non-existent symbol
        tick = self.realtime_manager.get_last_tick("NONEXISTENT")
        self.assertIsNone(tick)
    
    def test_register_callback(self):
        """Test registering a callback function."""
        # Define a callback function
        def test_callback():
            pass
        
        # Call the method
        result = self.realtime_manager.register_callback('on_tick', test_callback)
        
        # Check if callback was registered
        self.assertEqual(self.realtime_manager.callbacks['on_tick'], test_callback)
        
        # Check return value
        self.assertTrue(result)
        
        # Test for invalid event type
        result = self.realtime_manager.register_callback('invalid_event', test_callback)
        self.assertFalse(result)
    
    def test_on_ticks(self):
        """Test _on_ticks callback."""
        # Set up instance variables
        self.realtime_manager.token_symbol_map = self.test_token_symbol_map
        
        # Define a mock callback
        mock_callback = MagicMock()
        self.realtime_manager.callbacks['on_tick'] = mock_callback
        
        # Call the method
        ws = MagicMock()
        ticks = [self.test_tick]
        self.realtime_manager._on_ticks(ws, ticks)
        
        # Check if latest_ticks was updated
        self.assertEqual(self.realtime_manager.latest_ticks["RELIANCE"], self.test_tick)
        
        # Check if callback was called
        mock_callback.assert_called_once_with("RELIANCE", self.test_tick)
    
    def test_on_connect(self):
        """Test _on_connect callback."""
        # Set up instance variables
        self.realtime_manager.ticker = self.mock_ticker
        self.realtime_manager.subscribed_tokens = self.test_tokens
        
        # Define a mock callback
        mock_callback = MagicMock()
        self.realtime_manager.callbacks['on_connect'] = mock_callback
        
        # Call the method
        ws = MagicMock()
        response = {'status': 'success'}
        self.realtime_manager._on_connect(ws, response)
        
        # Check if is_connected was updated
        self.assertTrue(self.realtime_manager.is_connected)
        
        # Check if subscribe was called
        self.mock_ticker.subscribe.assert_called_once_with(self.test_tokens)
        
        # Check if set_mode was called
        self.mock_ticker.set_mode.assert_called_once()
        
        # Check if callback was called
        mock_callback.assert_called_once_with(response)

if __name__ == '__main__':
    unittest.main()```

### ./tests/test_risk.py

Type: Python Source Code
Size: 0
```py
```

### ./tests/test_strategy.py

Type: Python Source Code
Size: 0
```py
```

### ./tests/test_system.py

Type: Python Source Code
Size: 0
```py
```

### ./test_websocket.py

Type: Python Source Code
Size: 8.0K
```py
#!/usr/bin/env python
"""
WebSocket Test Script for Real-Time Data

This script tests the WebSocket connection with Zerodha's streaming API
using the RealTimeDataManager class.

It connects to Zerodha's WebSocket server, subscribes to a few symbols,
and displays real-time market data as it arrives.

Usage:
    python test_websocket.py [--symbols RELIANCE TCS INFY] [--duration 60]
"""
import os
import sys
import time
import argparse
import logging
from datetime import datetime
from dotenv import load_dotenv

# Import our modules
from auth.zerodha_auth import ZerodhaAuth
from data.historical_data import HistoricalDataManager
from data.realtime_data import RealTimeDataManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="Test WebSocket connection for real-time data")
    
    parser.add_argument(
        "--symbols", 
        type=str, 
        nargs="+", 
        default=["RELIANCE", "TCS", "INFY", "HDFCBANK", "ICICIBANK"],
        help="List of trading symbols to subscribe to"
    )
    
    parser.add_argument(
        "--duration", 
        type=int, 
        default=60,
        help="Duration to run the WebSocket test (in seconds)"
    )
    
    return parser.parse_args()

def on_tick(symbol, tick):
    """Callback for tick data."""
    # Get formatted timestamp
    timestamp = datetime.now().strftime('%H:%M:%S')
    
    # Format the output based on the available fields in the tick
    ltp = tick.get('last_price', 'N/A')
    volume = tick.get('volume_traded', 'N/A')
    last_quantity = tick.get('last_traded_quantity', 'N/A')
    
    # Print the tick information
    print(f"[{timestamp}] {symbol}: ₹{ltp} | Vol: {volume} | Last Qty: {last_quantity}")

def test_websocket():
    """Test the WebSocket connection."""
    # Parse command line arguments
    args = parse_arguments()
    
    print("\n" + "="*80)
    print("WEBSOCKET TEST FOR REAL-TIME DATA")
    print("="*80)
    
    # Load environment variables
    load_dotenv()
    
    # Get API key, secret, and access token from environment variables
    api_key = os.getenv("KITE_API_KEY")
    api_secret = os.getenv("KITE_API_SECRET")
    access_token = os.getenv("KITE_ACCESS_TOKEN")
    
    if not api_key or not api_secret or not access_token:
        logger.error("API key, secret, and access token are required")
        logger.error("Please run the authentication script first")
        return False
    
    # Initialize ZerodhaAuth
    try:
        auth = ZerodhaAuth(api_key, api_secret, access_token)
        
        # Validate connection
        if not auth.validate_connection():
            logger.error("Connection validation failed. Your access token may be expired.")
            logger.error("Please run the authentication script again to get a new access token.")
            return False
            
        logger.info("Authentication successful")
        
        # Get KiteConnect instance
        kite = auth.get_kite()
    except Exception as e:
        logger.error(f"Authentication failed: {e}")
        return False
    
    # Initialize HistoricalDataManager to get instrument tokens
    data_manager = HistoricalDataManager(kite)
    
    # Get instrument tokens for the symbols
    try:
        logger.info(f"Getting instrument tokens for {len(args.symbols)} symbols...")
        token_map = data_manager.get_instrument_tokens(args.symbols)
        
        if not token_map:
            logger.error("No instrument tokens found for the specified symbols")
            return False
            
        # Create the reverse mapping (token to symbol)
        symbol_token_map = {v: k for k, v in token_map.items()}
        tokens = list(token_map.values())
        
        # Print tokens
        for symbol, token in token_map.items():
            logger.info(f"{symbol}: {token}")
        
    except Exception as e:
        logger.error(f"Failed to get instrument tokens: {e}")
        return False
    
    # Initialize RealTimeDataManager
    realtime_manager = RealTimeDataManager(api_key, access_token)
    
    # Register callback for tick data
    realtime_manager.register_callback('on_tick', on_tick)
    
    # Define callbacks for connection events
    def on_connect(response):
        logger.info(f"Connected to WebSocket server: {response}")
    
    def on_close(code, reason):
        logger.warning(f"WebSocket connection closed: {code} - {reason}")
    
    def on_error(code, reason):
        logger.error(f"WebSocket error: {code} - {reason}")
    
    # Register callbacks
    realtime_manager.register_callback('on_connect', on_connect)
    realtime_manager.register_callback('on_close', on_close)
    realtime_manager.register_callback('on_error', on_error)
    
    # Subscribe to tokens
    realtime_manager.subscribe(tokens, symbol_token_map, token_map)
    
    # Start the WebSocket connection
    try:
        logger.info("Starting WebSocket connection...")
        if not realtime_manager.start():
            logger.error("Failed to start WebSocket connection")
            return False
        
        # Main loop
        logger.info(f"WebSocket connection started. Running for {args.duration} seconds...")
        logger.info("Press Ctrl+C to stop earlier.")
        
        try:
            start_time = time.time()
            while time.time() - start_time < args.duration:
                time.sleep(0.1)  # Small sleep to reduce CPU usage
        
        except KeyboardInterrupt:
            logger.info("Test stopped by user")
        
        # Stop the WebSocket connection
        logger.info("Stopping WebSocket connection...")
        realtime_manager.stop()
        
        print("\n" + "="*80)
        print("WEBSOCKET TEST COMPLETED")
        print("="*80)
        
        return True
        
    except Exception as e:
        logger.error(f"WebSocket test failed: {e}")
        return False

if __name__ == "__main__":
    if not test_websocket():
        sys.exit(1)```

### ./utils/helpers.py

Type: Python Source Code
Size: 0
```py
```

### ./utils/__init__.py

Type: Python Source Code
Size: 4.0K
```py
"""utils module for the trading system."""
```

### ./utils/logger.py

Type: Python Source Code
Size: 0
```py
```

## END OF PROJECT CONTEXT DOCUMENT

